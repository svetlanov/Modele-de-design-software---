# Лабораторная работа 9  
## Тема: Nullability

В этой лабораторной работе я познакомилась с механизмом **nullable reference types** в C#, понятием `null`, оператором `?` и `!`, а также с настройками проекта, которые заставляют относиться к предупреждениям компилятора как к ошибкам.

---

## Теория и вопросы

### Что такое `null`?

`null` — это отсутствие значения. Переменная со значением `null` не ссылается ни на какой объект, и любая попытка обратиться к её членам приводит к ошибке `NullReferenceException`.

---

### Почему тип `int` не позволяет значение `null`?

`int` является типом-значением, и он всегда хранит конкретное число. У него нет состояния «пусто», поэтому обычный `int` не может принимать `null`. Если нужно значение, которое может отсутствовать, используется `int?`.

---

### Что означает `string?`

`string?` — это строка, которая может быть `null`. Такой тип даёт компилятору понять, что отсутствие значения допустимо, и программист обязан учитывать этот сценарий в коде.

---

### Почему `int?` и `string?` работают по-разному?

`int?` становится новым типом (`Nullable<int>`), который хранит признак наличия значения.  
`string?` остаётся обычной `string`, а `?` влияет только на предупреждения компилятора.  
То есть `int?` меняет реальный тип данных, а `string?` — лишь правила анализа nullability.

---

### Что делает оператор `!` (null-forgiving operator)?

Оператор `!` сообщает компилятору, что значение точно не является `null`, и убирает предупреждение.  
При этом ответственность за возможную ошибку полностью ложится на программиста — в рантайме `null` всё равно возможен.

---

### Пример обхода гарантий nullability с помощью `!`

```csharp
string? s = GetValueOrNull();
string value = s!; // подавляем предупреждение
Console.WriteLine(value.Length); // может случиться NullReferenceException
```

Ещё пример:

```csharp
Dictionary<string, string?> d = new();
d["name"] = null;
string name = d["name"]!; // компилятор думает, что не null
```

Оператор `!` отключает анализ и может привести к ошибкам в рантайме.

---

### Чего позволяет достичь `required`?

Ключевое слово `required` заставляет инициализировать важные поля при создании объекта.  
Это помогает избежать пропуска обязательных данных и снижает вероятность получения `null` там, где его быть не должно.

Например:

```csharp
struct Book
{
    public required string Name;
    public required int Year;
    public required bool Available;
}
```

Если попытаться создать `Book` без указания всех `required`-полей:

```csharp
var b = new Book(); // компилятор выдаст ошибку
```

---

## Настройка nullability в проекте

В задании нужно было:

1. Включить nullability.  
2. Включить режим, когда **предупреждения компилятора считаются ошибками**.

Это делается в файле проекта `.csproj`. Например, для моей программы из ЛР 8 (библиотека):

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net9.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <Nullable>enable</Nullable>
  </PropertyGroup>
</Project>
```

- `<Nullable>enable</Nullable>` — включает анализ nullability для ссылочных типов.  
- `<TreatWarningsAsErrors>true</TreatWarningsAsErrors>` — любые предупреждения компилятора превращаются в ошибки, и проект не скомпилируется, пока их не исправить.

---

# Исправление проблем после включения Nullability (ЛР 8 — Библиотека)

После включения настроек:

```xml
<Nullable>enable</Nullable>
<TreatWarningsAsErrors>true</TreatWarningsAsErrors>
```

в программе возникли несколько предупреждений, которые я исправила.

---

## 1. Неинициализированная переменная `Book b`
В коде был фрагмент:

```csharp
Book b;
b.available = true;
```

После включения nullability компилятор сообщил об ошибке: структура `Book` имеет `required`-поля (`name`, `year`), но они не были инициализированы.  
Этот фрагмент был лишним, поэтому я **удалила его полностью**.

---

## 2. Структура `Book` с полями `required`
Моя структура:

```csharp
struct Book
{
    public required string name;
    public required int year;
    public required bool available;
}
```

Все книги инициализируются через объектный инициализатор:

```csharp
new Book { name = "...", year = 1977, available = true }
```

Поэтому дополнительных ошибок nullability не возникло.

---

## 3. `Console.ReadLine()` может вернуть null
В функциях `borrowBook` и `returnBook` я использую:

```csharp
string borrowedBook = Console.ReadLine()!;
```

Компилятор предупреждает, что `ReadLine()` может вернуть `null`.  
Для подавления предупреждения я применила оператор `!`, так как в рамках лабораторной достаточно показать понимание механизма nullability.

---
## Итог

После исправлений проект успешно компилируется без предупреждений и соответствует требованиям задания.

---
