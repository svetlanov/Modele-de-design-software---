# Лабораторная работа 6 
## Тема: Алгоритмы

В этой лабораторной работе я изучила понятие алгоритма, уровни абстракции, декомпозицию задач, списки, массивы и подход к решению сложных задач.

---

# Как подходить к решению сложных задач?

При решении сложной задачи нужно применять декомпозицию:

1. Проанализировать общую задачу.  
2. Разбить её на крупные подзадачи.  
3. Каждую подзадачу снова разбивать на более мелкие части.  
4. Продолжать так, пока мы не получим элементарные шаги, которые можно выполнить напрямую.  
5. Выполнить эти шаги или использовать готовый алгоритм.

Пример из задания: «Приготовить комплексный обед» — это высокая абстракция.  
Её можно разделить на подзадачи: приготовить первое, второе, напиток.  
Каждая подзадача дальше делится на шаги: подготовка ингредиентов, посуда, последовательность действий.

---

# Вопросы

## Как список чисел записать в линейной памяти?

Как массив — элементы располагаются подряд в соседних ячейках памяти, доступных по индексу.

---

## Что нужно сделать, чтобы пройтись по всем элементам списка или посчитать сумму?

Всегда требуется переменная «текущего состояния»:  
- текущий индекс,  
- текущая сумма,  
- или текущий элемент.  
В алгоритмах — это всегда отдельная ячейка памяти.

---

## Пример алгоритма, который ссылается на другой алгоритм

Алгоритм сортировки ссылается на алгоритм сравнения элементов.  
Алгоритм поиска пути использует алгоритм обхода графа.  
Алгоритм подсчёта среднего использует алгоритм подсчёта суммы.

---

# Практика  
## Задача: попарная сумма элементов двух списков

**Формулировка:**  
Дано два списка одинаковой длины. Требуется вычислить попарную сумму элементов:  
первый элемент + первый, второй + второй и так далее.

---

# Алгоритм (упрощенный):

1. Завести новый список `result` выбранной длины.  
2. Ввести переменную `i = 0`.  
3. Пока `i` меньше длины списка:  
   - взять `list1[i]`,  
   - взять `list2[i]`,  
   - вычислить их сумму,  
   - записать сумму в `result[i]`,  
   - увеличить `i` на 1.  
4. Вывести список `result`.

---

# Алгоритм (более подробный):
## Этап 1. Подготовка данных

1. Получить первый список чисел и назвать его `list1`.
2. Получить второй список чисел и назвать его `list2`.
3. Определить длину первого списка и сохранить её в переменную `n`.
4. Проверить, что длина второго списка также равна `n`.  
   - Если длины не совпадают — алгоритм не может быть выполнен корректно.
5. Убедиться, что оба списка содержат числа и допускают доступ по индексу.

---

## Этап 2. Создание списка результата

6. Создать новый пустой список `result`.
7. Установить длину `result` равной `n` (количеству элементов во входных списках).
8. При необходимости инициализировать элементы `result` начальными значениями (например, нулями).

---

## Этап 3. Инициализация счётчика

9. Создать переменную `i` — индекс для обхода списков.
10. Присвоить переменной `i` значение `0`.

---

## Этап 4. Основной цикл (попарное сложение)

11. Проверить условие: `i < n`.  
    - Если условие ложное — перейти к Этапу 5.  
    - Если истинное — продолжить пункты ниже.

12. Прочитать элемент `list1[i]` и сохранить его во временную переменную `a`.
13. Прочитать элемент `list2[i]` и сохранить его во временную переменную `b`.
14. Вычислить сумму элементов: `s = a + b`.
15. Записать сумму по индексу `i` в список результата: `result[i] = s`.
16. Увеличить `i` на 1: `i = i + 1`.
17. Вернуться к пункту 11.

---

## Этап 5. Вывод результата

18. Подготовить переменную индекса для вывода, например `j = 0`.
19. Проверить условие: `j < n`.  
    - Если ложное — перейти к пункту 24.  
    - Если истинное — продолжить.

20. Прочитать элемент `result[j]`.
21. Вывести его на экран (в консоль или в другой установленный канал вывода).
22. Увеличить `j` на 1: `j = j + 1`.
23. Вернуться к пункту 19.

---

## Этап 6. Завершение работы алгоритма

24. Завершить выполнение.

---

# Итог

В этой работе я научилась декомпозировать сложные задачи, определять уровень абстракции, работать со списками и строить алгоритмы пошагово. Освоила принцип «переменной текущего состояния» и смогла применить его в задаче попарного сложения списков.

